extern def readFileBytes(filename: *Byte, length: *Int): *Byte
extern def printLine(text: *Byte, length: Int): Unit
extern def fail(): Unit

struct SourceFile {
	data: Seq[Byte]
	position: Int
}

struct Token {
	file: *SourceFile
	type: Int
	begin, end: Int
}

val TokIdent = 1001
val TokString = 1002
val TokNumber = 1003

val TokPostEq = 2000
val TokAddAssign = TokPostEq + c"+"
val TokSubAssign = TokPostEq + c"-"
val TokMulAssign = TokPostEq + c"*"
val TokDivAssign = TokPostEq + c"/"
val TokEqual = TokPostEq + c"="
val TokNotEqual = TokPostEq + c"!"
val TokLessEqual = TokPostEq + c"<"
val TokGreaterEqual = TokPostEq + c">"

val TokAnd = 3001
val TokOr = 3002

def loadFile(f: *SourceFile, filename: String): Unit = {
	val cstr: Array[Byte, 1024]
	for (var i = 0; i < filename.count; i += 1) {
		cstr[i] = filename[i]
	}
	cstr[filename.count] = 0

	var length = 0
	val bytes = readFileBytes(cstr, &length)

	f.data = Seq(bytes, length)
	f.position = 0
}

def peek(f: *SourceFile): Byte = {
	if (f.position < f.data.count) {
		f.data[f.position]
	} else 0
}

def eat(f: *SourceFile): Byte = {
	if (f.position < f.data.count) f.position += 1
	peek(f)
}

def error(token: Token, message: String): Unit = {
	printLine(message.data, message.count)
	fail()
}

def range(c: Byte, bounds: Seq[Byte]): Bool = c >= bounds[0] && c <= bounds[1]

def contained(c: Byte, options: Seq[Byte]): Bool = {
	for (var i = 0; i < options.count; i += 1) {
		if (c == options[i]) return true
	}
	false
}

def lex(f: *SourceFile): Token = {
	var c = peek(f)

label whitespace:
	while (c == c" " || c == c"\t" || c == c"\r") {
		c = eat(f)
	}

	var tok: Token = { file = f; begin = f.position }

	if (c == c"/") {
		val la = eat(f)
		if (la == c"/") {
			do {
				c = eat(f)
			} while(c != c"\n" && c != c"\0")
			goto whitespace
		} else if (la == c"=") {
			tok.type = c"/"
			goto accept
		} else {
			tok.type = TokDivAssign
			goto accept
		}
	}

	if (range(c, "AZ") || range(c, "az") || c == c"_") {
		do {
			c = eat(f)
		} while (range(c, "AZ") || range(c, "az") || range(c, "09") || c == c"_")

		if (c == c"\"") {
			goto string
		} else {
			tok.type = TokIdent
			goto accept
		}
	}

	if (range(c, "09")) {
		do {
			c = eat(f)
		} while (range(c, "09"))
		
		tok.type = TokNumber
		goto accept
	}

label string:
	if (c == c"\"") {
		do {
			c = eat(f)
			if (c == c"\\") {
				if (eat(f) == 0) error(tok, "Expected an escape sequence")
			}
			if (c == c"\n") error(tok, "Newline in string")
		} while (c != c"\"" && c != c"\0")

		if (c != c"\"") {
			error(tok, "String not closed")
		} else {
			tok.type = TokString
			goto accept
		}
	}

	val la = eat(f)
	if (contained(c, ":()[]{};\n") || c == c"\0") {
		tok.type = c
	} else if (contained(c, "+-/*!=")) {
		if (la == c"=") {
			tok.type = TokPostEq + c
		} else {
			tok.type = c
		}
	} else if (c == c"&") {
		tok.type = if (la == c) TokAnd else c
	} else if (c == c"|") {
		tok.type = if (la == c) TokOr else c
	} else {
		error(tok, "Unexpected character")
	}

label accept:
	tok.end = f.position
	tok
}

